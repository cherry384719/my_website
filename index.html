<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>综合游戏平台</title>
    <style>
        :root {
            --primary-color: #8f7a66;
            --secondary-color: #bbada0; 
            --accent-color: #f59563;
            --bg-color: #faf8ef;
            --text-dark: #776e65;
            --text-light: #f9f6f2;
            --cell-bg: #cdc1b4;
            --board-bg: #bbada0;
            --font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .game-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            margin: 10px 0 0;
            opacity: 0.9;
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .nav-tab {
            flex: 1;
            padding: 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: var(--text-dark);
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            background: #e9ecef;
        }

        .nav-tab.active {
            background: white;
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        /* Game Content */
        .game-content {
            padding: 20px;
            min-height: 500px;
        }

        .game-section {
            display: none;
        }

        .game-section.active {
            display: block;
        }

        /* Common Game Styles */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .score-display {
            background: var(--secondary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        .control-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease;
            font-size: 14px;
        }

        .control-btn:hover {
            background: var(--accent-color);
        }

        /* 2048 Game Styles */
        .game-2048 .game-board {
            background-color: var(--board-bg);
            border-radius: 6px;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 15px;
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            aspect-ratio: 1;
        }

        .game-2048 .grid-cell {
            background-color: var(--cell-bg);
            border-radius: 3px;
        }

        .game-2048 .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            border-radius: 3px;
            transition: all 150ms ease-in-out;
            font-size: 35px;
        }

        .game-2048 .tile.new-tile {
            animation: appear 200ms ease-in-out;
        }

        .game-2048 .tile.merged-tile {
            animation: pop 200ms ease-in-out;
        }

        /* Snake Game Styles */
        .game-snake .snake-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
        }

        .game-snake .game-canvas {
            border: 3px solid var(--primary-color);
            border-radius: 10px;
            background: #2d3748;
        }

        .snake-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Tetris Game Styles */
        .game-tetris .tetris-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
        }

        .game-tetris .tetris-board {
            border: 3px solid var(--primary-color);
            border-radius: 10px;
            background: #1a1a1a;
        }

        .tetris-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-width: 220px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .next-piece-container {
            background: white;
            border: 2px solid var(--secondary-color);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .next-piece-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 14px;
        }

        .next-piece-canvas {
            background: #1a1a1a;
            border-radius: 5px;
            margin: 0 auto;
        }

        /* Game Status Display */
        .game-status {
            text-align: center;
            padding: 20px;
            font-size: 18px;
            font-weight: bold;
            color: var(--text-dark);
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
        }

        .game-status.ready {
            color: #28a745;
        }

        .game-status.running {
            color: #007bff;
        }

        .game-status.paused {
            color: #ffc107;
        }

        .game-status.over {
            color: #dc3545;
        }

        /* Animations */
        @keyframes appear {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }

        @keyframes pop {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        /* Tile Colors for 2048 */
        .tile[data-value="2"] { background-color: #eee4da; color: #776e65; }
        .tile[data-value="4"] { background-color: #ede0c8; color: #776e65; }
        .tile[data-value="8"] { background-color: #f2b179; color: #f9f6f2; }
        .tile[data-value="16"] { background-color: #f59563; color: #f9f6f2; }
        .tile[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; }
        .tile[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; }
        .tile[data-value="128"] { background-color: #edcf72; color: #f9f6f2; font-size: 30px; }
        .tile[data-value="256"] { background-color: #edcc61; color: #f9f6f2; font-size: 30px; }
        .tile[data-value="512"] { background-color: #edc850; color: #f9f6f2; font-size: 30px; }
        .tile[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; font-size: 25px; }
        .tile[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; font-size: 25px; }

        /* Game Over Overlay */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(238, 228, 218, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--text-dark);
            font-size: 40px;
            font-weight: bold;
            text-align: center;
            animation: fade-in 500ms ease-in-out;
            z-index: 100;
            border-radius: 6px;
        }

        .game-overlay.win {
            background-color: rgba(237, 194, 46, 0.8);
            color: white;
        }

        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .overlay-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: background 0.3s ease;
        }

        .overlay-btn:hover {
            background: var(--accent-color);
        }

        /* Instructions */
        .instructions {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            color: var(--text-dark);
        }

        .instructions h3 {
            margin: 0 0 10px;
            color: var(--primary-color);
        }

        /* Responsive */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .header h1 { font-size: 2em; }
            .nav-tab { padding: 12px 8px; font-size: 14px; }
            .game-content { padding: 15px; }
            .game-2048 .tile { font-size: 28px; }
            .game-2048 .tile[data-value="128"], 
            .game-2048 .tile[data-value="256"], 
            .game-2048 .tile[data-value="512"] { font-size: 24px; }
            .game-2048 .tile[data-value="1024"], 
            .game-2048 .tile[data-value="2048"] { font-size: 20px; }
            .snake-info, .tetris-info { min-width: auto; width: 100%; }
            .game-header { justify-content: center; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>🎮 综合游戏平台</h1>
            <p>包含多种经典游戏，享受游戏乐趣！</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchGame('game2048')">2048</button>
            <button class="nav-tab" onclick="switchGame('snake')">贪吃蛇</button>
            <button class="nav-tab" onclick="switchGame('tetris')">俄罗斯方块</button>
        </div>

        <div class="game-content">
            <!-- 2048 Game -->
            <div id="game2048" class="game-section game-2048 active">
                <div class="instructions">
                    <h3>游戏说明</h3>
                    <p>使用方向键或滑动来移动数字块，相同数字相撞时会合并。目标是创造出2048！</p>
                </div>
                <div class="game-header">
                    <div class="score-display">分数: <span id="score2048">0</span></div>
                    <div class="score-display">最佳: <span id="best2048">0</span></div>
                    <button class="control-btn" onclick="startGame2048()">新游戏</button>
                </div>
                <div class="game-board" id="board2048"></div>
            </div>

            <!-- Snake Game -->
            <div id="snake" class="game-section game-snake">
                <div class="instructions">
                    <h3>游戏说明</h3>
                    <p>使用方向键控制蛇的移动，吃到食物会变长，不要撞到墙壁或自己！</p>
                </div>
                <div class="game-status" id="snakeStatus">准备开始游戏</div>
                <div class="snake-container">
                    <canvas id="snakeCanvas" class="game-canvas" width="400" height="400"></canvas>
                    <div class="snake-info">
                        <div class="score-display">分数: <span id="scoreSnake">0</span></div>
                        <div class="score-display">最佳: <span id="bestSnake">0</span></div>
                        <div class="score-display">长度: <span id="snakeLength">1</span></div>
                        <button class="control-btn" id="startSnakeBtn" onclick="startSnakeGame()">开始游戏</button>
                        <button class="control-btn" onclick="pauseSnakeGame()" id="pauseSnakeBtn" style="display: none;">暂停</button>
                    </div>
                </div>
            </div>

            <!-- Tetris Game -->
            <div id="tetris" class="game-section game-tetris">
                <div class="instructions">
                    <h3>游戏说明</h3>
                    <p>使用方向键移动和旋转方块，填满一行即可消除。左右键移动，上键旋转，下键快速下落！</p>
                </div>
                <div class="game-status" id="tetrisStatus">准备开始游戏</div>
                <div class="tetris-container">
                    <canvas id="tetrisCanvas" class="tetris-board" width="300" height="600"></canvas>
                    <div class="tetris-info">
                        <div class="score-display">分数: <span id="scoreTetris">0</span></div>
                        <div class="score-display">等级: <span id="levelTetris">1</span></div>
                        <div class="score-display">行数: <span id="linesTetris">0</span></div>
                        
                        <div class="next-piece-container">
                            <div class="next-piece-title">下一个方块</div>
                            <canvas id="nextPieceCanvas" class="next-piece-canvas" width="120" height="120"></canvas>
                        </div>
                        
                        <button class="control-btn" onclick="startTetrisGame()" id="startTetrisBtn">开始游戏</button>
                        <button class="control-btn" onclick="pauseTetrisGame()" id="pauseTetrisBtn" style="display: none;">暂停</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let currentGame = 'game2048';
        let gameStates = {
            game2048: { active: false },
            snake: { active: false, paused: false },
            tetris: { active: false, paused: false }
        };

        // Game Switching
        function switchGame(gameId) {
            // Stop current game
            stopCurrentGame();
            
            // Update UI
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.game-section').forEach(section => section.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(gameId).classList.add('active');
            currentGame = gameId;

            // Initialize canvases for Snake and Tetris when switching to them
            if (gameId === 'snake') {
                initializeSnakeCanvas();
            } else if (gameId === 'tetris') {
                initializeTetrisCanvas();
            }
        }

        function stopCurrentGame() {
            gameStates[currentGame].active = false;
            gameStates[currentGame].paused = false;
            
            if (currentGame === 'snake' && window.snakeGameLoop) {
                clearInterval(window.snakeGameLoop);
                window.snakeGameLoop = null;
            }
            if (currentGame === 'tetris' && window.tetrisGameLoop) {
                clearInterval(window.tetrisGameLoop);
                window.tetrisGameLoop = null;
            }
        }

        // Local Storage Helper
        function getBestScore(game) {
            return localStorage.getItem(`best_${game}`) || 0;
        }

        function setBestScore(game, score) {
            const best = getBestScore(game);
            if (score > best) {
                localStorage.setItem(`best_${game}`, score);
                return true;
            }
            return false;
        }

        // ===================
        // 2048 GAME
        // ===================
        let game2048 = {
            gridSize: 4,
            grid: [],
            score: 0,
            isGameOver: false,
            hasWon: false,
            touchStart: { x: null, y: null },
            touchEnd: { x: null, y: null }
        };

        function startGame2048() {
            const board = document.getElementById('board2048');
            board.innerHTML = '';
            
            // Create grid cells
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                board.appendChild(cell);
            }

            game2048.grid = Array.from({ length: 4 }, () => Array(4).fill(0));
            game2048.score = 0;
            game2048.isGameOver = false;
            game2048.hasWon = false;
            gameStates.game2048.active = true;

            updateScore2048();
            addRandomTile2048();
            addRandomTile2048();
            drawBoard2048();

            // Event listeners
            document.removeEventListener('keydown', handleKeyPress2048);
            document.addEventListener('keydown', handleKeyPress2048);
            
            board.removeEventListener('touchstart', handleTouchStart2048);
            board.removeEventListener('touchend', handleTouchEnd2048);
            board.addEventListener('touchstart', handleTouchStart2048);
            board.addEventListener('touchend', handleTouchEnd2048);
        }

        function handleKeyPress2048(e) {
            if (!gameStates.game2048.active || game2048.isGameOver || currentGame !== 'game2048') return;
            
            let moved = false;
            switch (e.key) {
                case 'ArrowUp': moved = move2048(0, -1); break;
                case 'ArrowDown': moved = move2048(0, 1); break;
                case 'ArrowLeft': moved = move2048(-1, 0); break;
                case 'ArrowRight': moved = move2048(1, 0); break;
                default: return;
            }
            e.preventDefault();

            if (moved) {
                setTimeout(() => {
                    addRandomTile2048();
                    drawBoard2048();
                    checkGameState2048();
                }, 100);
            }
        }

        function handleTouchStart2048(e) {
            e.preventDefault();
            game2048.touchStart.x = e.touches[0].clientX;
            game2048.touchStart.y = e.touches[0].clientY;
        }

        function handleTouchEnd2048(e) {
            if (!gameStates.game2048.active || game2048.isGameOver) return;
            e.preventDefault();
            
            game2048.touchEnd.x = e.changedTouches[0].clientX;
            game2048.touchEnd.y = e.changedTouches[0].clientY;

            const dx = game2048.touchEnd.x - game2048.touchStart.x;
            const dy = game2048.touchEnd.y - game2048.touchStart.y;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            if (Math.max(absDx, absDy) > 30) {
                let moved = false;
                if (absDy > absDx) {
                    moved = dy > 0 ? move2048(0, 1) : move2048(0, -1);
                } else {
                    moved = dx > 0 ? move2048(1, 0) : move2048(-1, 0);
                }

                if (moved) {
                    setTimeout(() => {
                        addRandomTile2048();
                        drawBoard2048();
                        checkGameState2048();
                    }, 100);
                }
            }
        }

        function move2048(dx, dy) {
            let moved = false;
            const newGrid = JSON.parse(JSON.stringify(game2048.grid));
            const merged = Array.from({ length: 4 }, () => Array(4).fill(false));

            const rows = dy === 1 ? [3,2,1,0] : [0,1,2,3];
            const cols = dx === 1 ? [3,2,1,0] : [0,1,2,3];

            for (const r of rows) {
                for (const c of cols) {
                    if (newGrid[r][c] !== 0) {
                        let newR = r, newC = c;
                        
                        while (true) {
                            const nextR = newR + dy;
                            const nextC = newC + dx;
                            
                            if (nextR < 0 || nextR >= 4 || nextC < 0 || nextC >= 4) break;
                            
                            if (newGrid[nextR][nextC] === 0) {
                                newR = nextR;
                                newC = nextC;
                            } else if (newGrid[nextR][nextC] === newGrid[r][c] && !merged[nextR][nextC]) {
                                newR = nextR;
                                newC = nextC;
                                break;
                            } else {
                                break;
                            }
                        }

                        if (newR !== r || newC !== c) {
                            if (newGrid[newR][newC] === newGrid[r][c]) {
                                newGrid[newR][newC] *= 2;
                                game2048.score += newGrid[newR][newC];
                                merged[newR][newC] = true;
                                if (newGrid[newR][newC] === 2048 && !game2048.hasWon) {
                                    game2048.hasWon = true;
                                }
                            } else {
                                newGrid[newR][newC] = newGrid[r][c];
                            }
                            newGrid[r][c] = 0;
                            moved = true;
                        }
                    }
                }
            }

            game2048.grid = newGrid;
            return moved;
        }

        function addRandomTile2048() {
            const emptyCells = [];
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (game2048.grid[r][c] === 0) {
                        emptyCells.push({ r, c });
                    }
                }
            }

            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                game2048.grid[r][c] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        function drawBoard2048() {
            const board = document.getElementById('board2048');
            const tiles = board.querySelectorAll('.tile');
            tiles.forEach(tile => tile.remove());

            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (game2048.grid[r][c] !== 0) {
                        createTile2048(r, c, game2048.grid[r][c]);
                    }
                }
            }
            updateScore2048();
        }

        function createTile2048(row, col, value) {
            const board = document.getElementById('board2048');
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.dataset.value = value;
            tile.textContent = value;

            const boardRect = board.getBoundingClientRect();
            const cellSize = (boardRect.width - 75) / 4; // 15px gaps * 5
            const gap = 15;

            tile.style.width = `${cellSize}px`;
            tile.style.height = `${cellSize}px`;
            tile.style.top = `${row * (cellSize + gap) + gap}px`;
            tile.style.left = `${col * (cellSize + gap) + gap}px`;

            board.appendChild(tile);
        }

        function updateScore2048() {
            document.getElementById('score2048').textContent = game2048.score;
            document.getElementById('best2048').textContent = getBestScore('game2048');
            
            if (setBestScore('game2048', game2048.score)) {
                document.getElementById('best2048').textContent = game2048.score;
            }
        }

        function checkGameState2048() {
            if (game2048.hasWon) {
                showOverlay2048('恭喜！您达到了2048！', 'win', '继续游戏');
            }
            
            if (!canMove2048()) {
                game2048.isGameOver = true;
                showOverlay2048('游戏结束！', 'lose', '重新开始');
            }
        }

        function canMove2048() {
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (game2048.grid[r][c] === 0) return true;
                    if (r < 3 && game2048.grid[r][c] === game2048.grid[r + 1][c]) return true;
                    if (c < 3 && game2048.grid[r][c] === game2048.grid[r][c + 1]) return true;
                }
            }
            return false;
        }

        function showOverlay2048(message, type, buttonText) {
            const board = document.getElementById('board2048');
            const overlay = document.createElement('div');
            overlay.classList.add('game-overlay');
            if (type === 'win') overlay.classList.add('win');
            
            overlay.innerHTML = `
                <div>${message}</div>
                <button class="overlay-btn" onclick="handleOverlayClick2048('${type}')">${buttonText}</button>
            `;
            
            board.style.position = 'relative';
            board.appendChild(overlay);
        }

        function handleOverlayClick2048(type) {
            const overlay = document.querySelector('.game-overlay');
            if (overlay) overlay.remove();
            
            if (type === 'win') {
                game2048.hasWon = false;
            } else {
                startGame2048();
            }
        }

        // ===================
        // SNAKE GAME
        // ===================
        let snake = {
            snake: [{ x: 200, y: 200 }],
            food: { x: 0, y: 0 },
            direction: { x: 20, y: 0 },
            score: 0,
            gameRunning: false
        };

        const SNAKE_CANVAS_WIDTH = 400;
        const SNAKE_CANVAS_HEIGHT = 400;
        const SNAKE_GRID_SIZE = 20;

        function initializeSnakeCanvas() {
            const canvas = document.getElementById('snakeCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Ensure canvas dimensions are set
            canvas.width = SNAKE_CANVAS_WIDTH;
            canvas.height = SNAKE_CANVAS_HEIGHT;
            
            // Clear canvas
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, SNAKE_CANVAS_WIDTH, SNAKE_CANVAS_HEIGHT);
            
            // Draw grid
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= SNAKE_CANVAS_WIDTH; i += SNAKE_GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, SNAKE_CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let i = 0; i <= SNAKE_CANVAS_HEIGHT; i += SNAKE_GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(SNAKE_CANVAS_WIDTH, i);
                ctx.stroke();
            }
            
            updateSnakeStatus('准备开始游戏', 'ready');
        }

        function startSnakeGame() {
            // Reset game state
            snake.snake = [{ x: 200, y: 200 }];
            snake.direction = { x: 20, y: 0 };
            snake.score = 0;
            snake.gameRunning = true;
            gameStates.snake.active = true;
            gameStates.snake.paused = false;
            
            // Ensure canvas is properly initialized
            const canvas = document.getElementById('snakeCanvas');
            if (canvas) {
                canvas.width = SNAKE_CANVAS_WIDTH;
                canvas.height = SNAKE_CANVAS_HEIGHT;
            }
            
            generateFood();
            updateScoreSnake();
            updateSnakeStatus('游戏进行中...', 'running');
            drawSnake();
            
            const startBtn = document.getElementById('startSnakeBtn');
            const pauseBtn = document.getElementById('pauseSnakeBtn');
            if (startBtn) startBtn.style.display = 'none';
            if (pauseBtn) pauseBtn.style.display = 'inline-block';
            
            document.removeEventListener('keydown', handleKeyPressSnake);
            document.addEventListener('keydown', handleKeyPressSnake);
            
            if (window.snakeGameLoop) clearInterval(window.snakeGameLoop);
            window.snakeGameLoop = setInterval(gameLoopSnake, 150);
        }

        function pauseSnakeGame() {
            gameStates.snake.paused = !gameStates.snake.paused;
            const btn = document.getElementById('pauseSnakeBtn');
            if (gameStates.snake.paused) {
                btn.textContent = '继续';
                updateSnakeStatus('游戏已暂停', 'paused');
            } else {
                btn.textContent = '暂停';
                updateSnakeStatus('游戏进行中...', 'running');
            }
        }

        function updateSnakeStatus(message, type) {
            const status = document.getElementById('snakeStatus');
            status.textContent = message;
            status.className = `game-status ${type}`;
        }

        function handleKeyPressSnake(e) {
            if (!gameStates.snake.active || !snake.gameRunning || currentGame !== 'snake' || gameStates.snake.paused) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    if (snake.direction.y === 0) snake.direction = { x: 0, y: -20 };
                    break;
                case 'ArrowDown':
                    if (snake.direction.y === 0) snake.direction = { x: 0, y: 20 };
                    break;
                case 'ArrowLeft':
                    if (snake.direction.x === 0) snake.direction = { x: -20, y: 0 };
                    break;
                case 'ArrowRight':
                    if (snake.direction.x === 0) snake.direction = { x: 20, y: 0 };
                    break;
                case ' ':
                    pauseSnakeGame();
                    break;
            }
            e.preventDefault();
        }

        function gameLoopSnake() {
            if (!snake.gameRunning || !gameStates.snake.active || gameStates.snake.paused) return;
            
            moveSnake();
            if (checkSnakeCollision()) {
                gameOverSnake();
                return;
            }
            if (checkFoodCollision()) {
                snake.score += 10;
                updateScoreSnake();
                generateFood();
            } else {
                snake.snake.pop();
            }
            drawSnake();
        }

        function moveSnake() {
            const head = { 
                x: snake.snake[0].x + snake.direction.x, 
                y: snake.snake[0].y + snake.direction.y 
            };
            snake.snake.unshift(head);
        }

        function checkSnakeCollision() {
            const head = snake.snake[0];
            // Fixed boundary collision detection
            return (
                head.x < 0 || head.x >= SNAKE_CANVAS_WIDTH || 
                head.y < 0 || head.y >= SNAKE_CANVAS_HEIGHT ||
                snake.snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)
            );
        }

        function checkFoodCollision() {
            return snake.snake[0].x === snake.food.x && snake.snake[0].y === snake.food.y;
        }

        function generateFood() {
            const maxX = Math.floor(SNAKE_CANVAS_WIDTH / SNAKE_GRID_SIZE);
            const maxY = Math.floor(SNAKE_CANVAS_HEIGHT / SNAKE_GRID_SIZE);
            
            snake.food = {
                x: Math.floor(Math.random() * maxX) * SNAKE_GRID_SIZE,
                y: Math.floor(Math.random() * maxY) * SNAKE_GRID_SIZE
            };
            
            // Ensure food doesn't spawn on snake
            while (snake.snake.some(segment => segment.x === snake.food.x && segment.y === snake.food.y)) {
                snake.food = {
                    x: Math.floor(Math.random() * maxX) * SNAKE_GRID_SIZE,
                    y: Math.floor(Math.random() * maxY) * SNAKE_GRID_SIZE
                };
            }
        }

        function drawSnake() {
            const canvas = document.getElementById('snakeCanvas');
            if (!canvas) {
                console.error('Snake canvas not found!');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Canvas context not available!');
                return;
            }
            
            // Clear canvas
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, SNAKE_CANVAS_WIDTH, SNAKE_CANVAS_HEIGHT);
            
            // Draw subtle grid
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= SNAKE_CANVAS_WIDTH; i += SNAKE_GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, SNAKE_CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let i = 0; i <= SNAKE_CANVAS_HEIGHT; i += SNAKE_GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(SNAKE_CANVAS_WIDTH, i);
                ctx.stroke();
            }
            
            // Draw snake with rounded corners
            if (snake.snake && snake.snake.length > 0) {
                snake.snake.forEach((segment, index) => {
                    ctx.fillStyle = index === 0 ? '#38a169' : '#48bb78'; // Head vs body
                    ctx.fillRect(segment.x + 1, segment.y + 1, SNAKE_GRID_SIZE - 2, SNAKE_GRID_SIZE - 2);
                    
                    if (index === 0) {
                        // Draw eyes on head
                        ctx.fillStyle = 'white';
                        const eyeSize = 3;
                        ctx.fillRect(segment.x + 5, segment.y + 4, eyeSize, eyeSize);
                        ctx.fillRect(segment.x + 12, segment.y + 4, eyeSize, eyeSize);
                    }
                });
            }
            
            // Draw food with animation
            if (snake.food) {
                ctx.fillStyle = '#f56565';
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 1;
                const foodSize = (SNAKE_GRID_SIZE - 2) * pulse;
                const offset = (SNAKE_GRID_SIZE - foodSize) / 2;
                ctx.fillRect(snake.food.x + offset, snake.food.y + offset, foodSize, foodSize);
            }
        }

        function updateScoreSnake() {
            document.getElementById('scoreSnake').textContent = snake.score;
            document.getElementById('snakeLength').textContent = snake.snake.length;
            document.getElementById('bestSnake').textContent = getBestScore('snake');
            setBestScore('snake', snake.score);
        }

        function gameOverSnake() {
            snake.gameRunning = false;
            gameStates.snake.active = false;
            clearInterval(window.snakeGameLoop);
            window.snakeGameLoop = null;
            setBestScore('snake', snake.score);
            document.getElementById('bestSnake').textContent = getBestScore('snake');
            const startBtn = document.getElementById('startSnakeBtn');
            const pauseBtn = document.getElementById('pauseSnakeBtn');
            if (startBtn) startBtn.style.display = 'inline-block';
            if (pauseBtn) pauseBtn.style.display = 'none';
            updateSnakeStatus(`游戏结束！最终得分：${snake.score}`, 'over');
        }

        // ===================
        // TETRIS GAME
        // ===================
        let tetris = {
            board: [],
            currentPiece: null,
            nextPiece: null,
            score: 0,
            level: 1,
            lines: 0,
            gameRunning: false,
            dropCounter: 0,
            dropInterval: 1000
        };

        const TETRIS_CANVAS_WIDTH = 300;
        const TETRIS_CANVAS_HEIGHT = 600;
        const TETRIS_CELL_SIZE = 30;

        const tetrisShapes = [
            [['....', '..##', '..##', '....']],  // O
            [['..#.', '.###', '....', '....'], ['....', '.##.', '.#..', '.#..'], ['....', '###.', '.#..', '....'], ['.#..', '.#..', '##..', '....']],  // T
            [['....', '####', '....', '....'], ['.#..', '.#..', '.#..', '.#..']],  // I
            [['....', '.##.', '.#..', '.#..'], ['....', '#...', '###.', '....'], ['.#..', '.#..', '##..', '....'], ['....', '###.', '..#.', '....']],  // J
            [['....', '##..', '.#..', '.#..'], ['....', '###.', '#...', '....'], ['#...', '#...', '##..', '....'], ['....', '..#.', '###.', '....']],  // L
            [['....', '.##.', '##..', '....'], ['.#..', '##..', '#...', '....']],  // S
            [['....', '##..', '.##.', '....'], ['....', '.#..', '##..', '#...']],  // Z
        ];

        function initializeTetrisCanvas() {
            const canvas = document.getElementById('tetrisCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear main canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, TETRIS_CANVAS_WIDTH, TETRIS_CANVAS_HEIGHT);
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= TETRIS_CANVAS_WIDTH; x += TETRIS_CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, TETRIS_CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= TETRIS_CANVAS_HEIGHT; y += TETRIS_CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(TETRIS_CANVAS_WIDTH, y);
                ctx.stroke();
            }
            
            // Initialize next piece canvas
            const nextCanvas = document.getElementById('nextPieceCanvas');
            const nextCtx = nextCanvas.getContext('2d');
            nextCtx.fillStyle = '#1a1a1a';
            nextCtx.fillRect(0, 0, 120, 120);
            
            updateTetrisStatus('准备开始游戏', 'ready');
        }

        function startTetrisGame() {
            // Initialize board
            tetris.board = Array.from({ length: 20 }, () => Array(10).fill(0));
            tetris.score = 0;
            tetris.level = 1;
            tetris.lines = 0;
            tetris.gameRunning = true;
            tetris.dropCounter = 0;
            tetris.dropInterval = 1000;
            gameStates.tetris.active = true;
            gameStates.tetris.paused = false;
            
            updateScoreTetris();
            spawnPiece();
            generateNextPiece();
            updateTetrisStatus('游戏进行中...', 'running');
            
            document.getElementById('startTetrisBtn').style.display = 'none';
            document.getElementById('startTetrisBtn').textContent = '开始游戏';
            document.getElementById('pauseTetrisBtn').style.display = 'inline-block';
            
            document.removeEventListener('keydown', handleKeyPressTetris);
            document.addEventListener('keydown', handleKeyPressTetris);
            
            if (window.tetrisGameLoop) clearInterval(window.tetrisGameLoop);
            window.tetrisGameLoop = setInterval(gameLoopTetris, 50);
        }

        function pauseTetrisGame() {
            gameStates.tetris.paused = !gameStates.tetris.paused;
            const btn = document.getElementById('pauseTetrisBtn');
            if (gameStates.tetris.paused) {
                btn.textContent = '继续';
                updateTetrisStatus('游戏已暂停', 'paused');
            } else {
                btn.textContent = '暂停';
                updateTetrisStatus('游戏进行中...', 'running');
            }
        }

        function updateTetrisStatus(message, type) {
            const status = document.getElementById('tetrisStatus');
            status.textContent = message;
            status.className = `game-status ${type}`;
        }

        function handleKeyPressTetris(e) {
            if (!gameStates.tetris.active || !tetris.gameRunning || currentGame !== 'tetris' || gameStates.tetris.paused) return;
            
            switch (e.key) {
                case 'ArrowLeft':
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    if (movePiece(0, 1)) {
                        tetris.score += 1; // Bonus for soft drop
                        updateScoreTetris();
                    }
                    tetris.dropCounter = 0;
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ':
                    pauseTetrisGame();
                    break;
            }
            e.preventDefault();
        }

        function gameLoopTetris() {
            if (!tetris.gameRunning || !gameStates.tetris.active || gameStates.tetris.paused) return;
            
            tetris.dropCounter += 50;
            if (tetris.dropCounter > tetris.dropInterval) {
                if (!movePiece(0, 1)) {
                    placePiece();
                    clearLines();
                    spawnPiece();
                    if (checkGameOver()) {
                        gameOverTetris();
                        return;
                    }
                }
                tetris.dropCounter = 0;
            }
            drawTetris();
        }

        function spawnPiece() {
            if (tetris.nextPiece) {
                tetris.currentPiece = tetris.nextPiece;
            } else {
                const shapeIndex = Math.floor(Math.random() * tetrisShapes.length);
                tetris.currentPiece = {
                    shape: tetrisShapes[shapeIndex][0],
                    x: 3,
                    y: 0,
                    rotation: 0,
                    shapeIndex: shapeIndex
                };
            }
            generateNextPiece();
        }

        function generateNextPiece() {
            const shapeIndex = Math.floor(Math.random() * tetrisShapes.length);
            tetris.nextPiece = {
                shape: tetrisShapes[shapeIndex][0],
                x: 3,
                y: 0,
                rotation: 0,
                shapeIndex: shapeIndex
            };
            drawNextPiece();
        }

        function drawNextPiece() {
            const canvas = document.getElementById('nextPieceCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 120, 120);
            
            if (!tetris.nextPiece) return;
            
            const colors = ['#000', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            ctx.fillStyle = colors[tetris.nextPiece.shapeIndex + 1];
            
            const cellSize = 25;
            const offsetX = 20;
            const offsetY = 20;
            
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (tetris.nextPiece.shape[y][x] !== '.') {
                        ctx.fillRect(
                            offsetX + x * cellSize, 
                            offsetY + y * cellSize, 
                            cellSize - 1, 
                            cellSize - 1
                        );
                    }
                }
            }
        }

        function movePiece(dx, dy) {
            tetris.currentPiece.x += dx;
            tetris.currentPiece.y += dy;
            
            if (checkTetrisCollision()) {
                tetris.currentPiece.x -= dx;
                tetris.currentPiece.y -= dy;
                return false;
            }
            return true;
        }

        function rotatePiece() {
            const shapes = tetrisShapes[tetris.currentPiece.shapeIndex];
            const oldRotation = tetris.currentPiece.rotation;
            tetris.currentPiece.rotation = (tetris.currentPiece.rotation + 1) % shapes.length;
            tetris.currentPiece.shape = shapes[tetris.currentPiece.rotation];
            
            if (checkTetrisCollision()) {
                tetris.currentPiece.rotation = oldRotation;
                tetris.currentPiece.shape = shapes[oldRotation];
            }
        }

        function checkTetrisCollision() {
            const piece = tetris.currentPiece;
            if (!piece || !piece.shape) return true; // Safety check
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (piece.shape[y][x] !== '.') {
                        const boardX = piece.x + x;
                        const boardY = piece.y + y;
                        if (boardX < 0 || boardX >= 10 || boardY >= 20 || 
                            (boardY >= 0 && tetris.board[boardY][boardX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function placePiece() {
            const piece = tetris.currentPiece;
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (piece.shape[y][x] !== '.') {
                        const boardX = piece.x + x;
                        const boardY = piece.y + y;
                        if (boardY >= 0 && boardY < 20 && boardX >= 0 && boardX < 10) {
                            tetris.board[boardY][boardX] = piece.shapeIndex + 1;
                        }
                    }
                }
            }
        }

        function clearLines() {
            let linesCleared = 0;
            for (let y = 19; y >= 0; y--) {
                if (tetris.board[y].every(cell => cell !== 0)) {
                    tetris.board.splice(y, 1);
                    tetris.board.unshift(Array(10).fill(0));
                    linesCleared++;
                    y++; // Check the same line again
                }
            }
            
            if (linesCleared > 0) {
                tetris.lines += linesCleared;
                // Score calculation based on Tetris scoring system
                const scoreMultiplier = [0, 40, 100, 300, 1200];
                const multiplier = linesCleared < scoreMultiplier.length ? scoreMultiplier[linesCleared] : scoreMultiplier[4];
                tetris.score += multiplier * tetris.level;
                tetris.level = Math.floor(tetris.lines / 10) + 1;
                tetris.dropInterval = Math.max(50, 1000 - (tetris.level - 1) * 100);
                updateScoreTetris();
            }
        }

        function checkGameOver() {
            // Check if any piece in the spawn area (top rows) would collide
            return tetris.board[0].some(cell => cell !== 0) || tetris.board[1].some(cell => cell !== 0);
        }

        function drawTetris() {
            const canvas = document.getElementById('tetrisCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, TETRIS_CANVAS_WIDTH, TETRIS_CANVAS_HEIGHT);
            
            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= TETRIS_CANVAS_WIDTH; x += TETRIS_CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, TETRIS_CANVAS_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= TETRIS_CANVAS_HEIGHT; y += TETRIS_CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(TETRIS_CANVAS_WIDTH, y);
                ctx.stroke();
            }
            
            // Draw placed pieces
            const colors = ['#000', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            
            for (let y = 0; y < 20; y++) {
                for (let x = 0; x < 10; x++) {
                    if (tetris.board[y][x]) {
                        ctx.fillStyle = colors[tetris.board[y][x]];
                        ctx.fillRect(x * TETRIS_CELL_SIZE, y * TETRIS_CELL_SIZE, TETRIS_CELL_SIZE - 1, TETRIS_CELL_SIZE - 1);
                        
                        // Add highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.fillRect(x * TETRIS_CELL_SIZE, y * TETRIS_CELL_SIZE, TETRIS_CELL_SIZE - 1, 4);
                    }
                }
            }
            
            // Draw current piece
            if (tetris.currentPiece) {
                ctx.fillStyle = colors[tetris.currentPiece.shapeIndex + 1];
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        if (tetris.currentPiece.shape[y][x] !== '.') {
                            const drawX = (tetris.currentPiece.x + x) * TETRIS_CELL_SIZE;
                            const drawY = (tetris.currentPiece.y + y) * TETRIS_CELL_SIZE;
                            ctx.fillRect(drawX, drawY, TETRIS_CELL_SIZE - 1, TETRIS_CELL_SIZE - 1);
                            
                            // Add highlight
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            ctx.fillRect(drawX, drawY, TETRIS_CELL_SIZE - 1, 4);
                            ctx.fillStyle = colors[tetris.currentPiece.shapeIndex + 1];
                        }
                    }
                }
            }
        }

        function updateScoreTetris() {
            document.getElementById('scoreTetris').textContent = tetris.score.toLocaleString();
            document.getElementById('levelTetris').textContent = tetris.level;
            document.getElementById('linesTetris').textContent = tetris.lines;
        }

        function gameOverTetris() {
            tetris.gameRunning = false;
            gameStates.tetris.active = false;
            clearInterval(window.tetrisGameLoop);
            window.tetrisGameLoop = null;
            setBestScore('tetris', tetris.score);
            
            document.getElementById('startTetrisBtn').style.display = 'inline-block';
            document.getElementById('startTetrisBtn').textContent = '重新开始';
            document.getElementById('pauseTetrisBtn').style.display = 'none';
            document.getElementById('bestTetris').textContent = getBestScore('tetris');
            
            updateTetrisStatus(`游戏结束！最终得分：${tetris.score.toLocaleString()}`, 'over');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Load best scores
            document.getElementById('best2048').textContent = getBestScore('game2048');
            document.getElementById('bestSnake').textContent = getBestScore('snake');
            
            // Initialize canvases with a small delay to ensure DOM is fully loaded
            setTimeout(() => {
                initializeSnakeCanvas();
                initializeTetrisCanvas();
            }, 100);
            
            // Start default game
            startGame2048();
        });
    </script>
</body>
</html>
